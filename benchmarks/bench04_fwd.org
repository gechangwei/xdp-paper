* Layer3 routing test
We use the xdp_fwd routing table helper for these benchmarks, compare with
baseline Linux.

: ./xdp_fwd -D ens1f1

Normal Linux forwarding also skip the rules lookup, so that corresponds to
xdp_fwd direct mode. But only if no rules have *ever* been installed since the
machine was rebooted. Removing the rules does *not* get it back in the optimised
lookup mode.

Measure throughput with ethtool_stats.pl (rx_xdp_redirect /sec). Adapter RX ring
set to different values:

: ethtool -G ens1f1 rx X

** Full routing table test

To run the full routing table test, a different trex script is used,
udp_multi_ip.py, which randomises the destination IPs. For this script the
stream_count parameter sets the number of dest IPs, and port_count sets the
number of dest UDP ports (for flow rule scaling at the receiver).

Running:

: start -f stl/udp_multi_ip.py -t packet_len=64,stream_count=20000,port_count=1 --port 0 -m 100%

Using larger numbers for stream_count takes a long time to setup! It's not
efficient! :)

20000 is the max number of streams supported by TRex, it seems. With this, TRex
can generate ~17Mpps on my machine. I also needed to increase the number of
mbufs in /etc/trex_cfg.yaml:

#+begin_example
  memory:
    mbuf_64: 200000
#+end_example

With 4000 streams, I can generate ~35Mpps, which is a bit above the maximum
forwarding rate with XDP, so that's what I'm going with.

Note that the randomly generated IPs may hit holes in the routing table, so make
sure there's either a default route or a covering route going to the same
destination. I use:

: ip r add 0.0.0.0/1 via 10.70.2.2
: ip r add 128.0.0.0/1 via 10.70.2.2

These are more specific than the default route (so that is still there if I want
to go out onto the internet), but covers everything.

** Data

#+NAME: fwd_data
| Cores | Linux (single route) | Linux (full table) | XDP (single route rxring 1024) | XDP (single route rxring 512) | XDP (single route rxring 256) | XDP (full table) |
|-------+----------------------+--------------------+--------------------------------+-------------------------------+-------------------------------+------------------|
|     1 |              1739672 |            1373550 |                        5211477 |                       5357696 |                       5355583 |          3446336 |
|     2 |              3370584 |            2746704 |                       10239315 |                      10570550 |                      10652337 |          7016974 |
|     3 |              4976559 |            3958725 |                       13731038 |                      15722609 |                      15937977 |         10641333 |
|     4 |              6488625 |            5295366 |                       16393261 |                      20192727 |                      21353932 |         14408549 |
|     5 |              7848970 |            6451024 |                       19364863 |                      23225298 |                      26056821 |         17870856 |
|     6 |              9285971 |            7809312 |                       22852944 |                      25916115 |                      30416566 |         21227330 |


#+BEGIN_SRC ipython :session :exports both :results raw drawer :var data=fwd_data
d = np.array(data)
plt.plot(d[:,0], d[:,5]/10**6, marker='o', label="XDP (single route)")
plt.plot(d[:,0], d[:,6]/10**6, marker='s', label="XDP (full table)")
plt.plot(d[:,0], d[:,1]/10**6, marker='^', label="Linux (single route)")
plt.plot(d[:,0], d[:,2]/10**6, marker='x', label="Linux (full table)")
plt.xlabel("Number of cores")
plt.ylabel("Mpps")
plt.legend()
plt.savefig(BASEDIR+"/figures/router-fwd.pdf", bbox_inches='tight')
plt.show()
#+END_SRC

#+RESULTS:
:results:
# Out[158]:
[[file:./obipy-resources/5egC7f.svg]]
:end:
